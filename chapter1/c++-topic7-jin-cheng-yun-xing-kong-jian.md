# topic7 - 进程运行空间分析


## 7.1 进程运行空间
程序编译链接成功后，要运行；由自己的虚地址空间，映射到物理地址空间进行运行；
可执行文件的虚地址空间，也就是进程运行空间，是怎么划分的？

linux-64bit机器为例：

![](/assets/1_7_1.jpg)


* 地址64bit,标识范围：0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF

* text segment: 代码段
二进制代码；从虚拟内存地址00400000开始，这个地址是固定的。使用pmap PID可以查看到；

* data segment:
存放已经初始化的全局变量，静态变量

* BSS segment：
未初始化的全局变量，会初始化默认值；

* heap 段：
c++动态内存分配运算符new,delete
c动态内存分配函数：malloc alloc  free


* Memeory mapping region:
**mmap系统调用可将文件**映射入进程memory map地址空间；
使用ldd命令，我们可以看到进程依赖的库文件，这些库文件编译过程中都要关联到此虚拟地址空间；

* stack 段：
函数局部变量，函数调用等都保存在stack区，地址由高到低的分配内存；

* 使用pmap PID 或 cat /proc/PID/maps 查看进程空间
maps文件格式：该文件有6列分别为：
地址：库在进程里地址范围
权限：虚拟内存的权限，r=读，w=写,x=,s=共享,p=私有；
偏移量：库在进程里地址范围
设备：映像文件的主设备号和次设备号；
节点：映像文件的节点号；
路径: 映像文件的路径
每项都与一个vm_area_struct结构成员对应
![](/assets/1_7_2.png)




## 7.2 x86-64寄存器体系和汇编指令


### 7.2.1 寄存器体系

![](/assets/1_7_3.png)

* 调用者保护：主函数作为调用者，调用子函数时，某些寄存器中的数据需要压栈保护，以便于恢复，不被覆盖；这个动作由主函数完成；对应的寄存器叫caller save

* 被调用者保护：callee save 子函数压栈保护寄存器中内容；

* %rax 通常用于存储函数调用的返回结果，同时也用于乘法和除法指令中。在imul 指令中，两个64位的乘法最多会产生128位的结果，需要 %rax 与 %rdx 共同存储乘法结果，在div 指令中被除数是128 位的，同样需要%rax 与 %rdx 共同存储被除数。

* %rsp 是**堆栈指针寄存器**，通常会指向栈顶位置，堆栈的 pop 和push 操作就是通过改变 %rsp 的值即移动堆栈指针的位置来实现的。

* %rbp 是**栈帧指针**，用于标识当前栈帧的起始位置

* %rdi, %rsi, %rdx, %rcx,%r8, %r9 六个寄存器用于存储函数调用时的6个参数（如果有6个或6个以上参数的话）。

### 7.2.2 常用汇编命令

![](/assets/1_7_4.png)


## 7.3 函数调用运行进制


### 7.3.1 函数栈帧

注意，这是**栈区**，存在函数调用时内存分布。
![](/assets/1_7_5.png)



## 7.4 常用汇编命令及寄存器


## 7.5 代码函数debug调试
